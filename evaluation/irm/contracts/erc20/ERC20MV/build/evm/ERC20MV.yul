/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 1:"./sources/ERC20MV.move"
///        , 2:"./../../../libs/stdlib/sources/U256.move"
///        , 3:"./../../../libs/stdlib/sources/Table.move"
///        , 4:"./../../../libs/stdlib/sources/Evm.move"


object "A2_ERC20MV" {
    code {
        mstore(0, memoryguard(160))
        let program_size := datasize("A2_ERC20MV")
        let arg_size := sub(codesize(), program_size)
        let memory_data_offset := $Malloc(arg_size)
        codecopy(memory_data_offset, program_size, arg_size)
        let param_0, param_1, param_2, param_3 := abi_decode_tuple_$string_string_address_uint256$_$vec$u8$_vec$u8$_address_A2_U256_U256$_from_memory(memory_data_offset, add(memory_data_offset, arg_size))
        let $new_value := A2_ERC20MV_create(param_0, param_1, param_2, param_3)
        {
            let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
            if $AlignedStorageLoad($base_offset) {
              $AbortBuiltin()
            }
            $AlignedStorageStore($base_offset, true)
            {
                let $dst := add($base_offset, 32)
                let $src := $new_value
                {
                    let $linked_src_2300595445 := mload(add($src, 0))
                    let $linked_dst_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                    let $size_2300595445 := $MemoryLoadU64($linked_src_2300595445)
                    let $data_size_2300595445 := mul($size_2300595445, 1)
                    $AlignedStorageStore($linked_dst_2300595445, mload($linked_src_2300595445))
                    let $data_src_2300595445 := add($linked_src_2300595445, 32)
                    let $data_dst_2300595445 := add($linked_dst_2300595445, 32)
                    for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                        $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                        $Free($linked_src_2300595445, add($data_size_2300595445, 32))
                    }
                    $AlignedStorageStore(add($dst, 0), $linked_dst_2300595445)
                }
                {
                    let $linked_src_2300595445 := mload(add($src, 32))
                    let $linked_dst_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                    let $size_2300595445 := $MemoryLoadU64($linked_src_2300595445)
                    let $data_size_2300595445 := mul($size_2300595445, 1)
                    $AlignedStorageStore($linked_dst_2300595445, mload($linked_src_2300595445))
                    let $data_src_2300595445 := add($linked_src_2300595445, 32)
                    let $data_dst_2300595445 := add($linked_dst_2300595445, 32)
                    for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                        $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                        $Free($linked_src_2300595445, add($data_size_2300595445, 32))
                    }
                    $AlignedStorageStore(add($dst, 32), $linked_dst_2300595445)
                }
                $AlignedStorageStore(add($dst, 64), mload(add($src, 64)))
                $AlignedStorageStore(add($dst, 96), mload(add($src, 96)))
                $AlignedStorageStore(add($dst, 128), mload(add($src, 128)))
                $Free($src, 160)
            }
        }
        codecopy(0, dataoffset("A2_ERC20MV_deployed"), datasize("A2_ERC20MV_deployed"))
        return(0, datasize("A2_ERC20MV_deployed"))
        function A2_ERC20MV_create(name, symbol, initial_account, initial_balance) -> $result {
            let tmp_$4, tmp_$5, tmp_$6, tmp_$7, tmp_$8, state, $t10, $t11, $t12, $t13, $t14
            // $t10 := U256::zero()
            /// @src 1:2124:2136
            $t10 := A2_U256_zero()
            // $t11 := Table::empty<address, U256::U256>()
            /// @src 1:2160:2189
            $t11 := A2_Table_empty$address_A2_U256_U256$()
            // $t12 := Table::empty<address, Table::Table<address, U256::U256>>()
            /// @src 1:2215:2260
            $t12 := A2_Table_empty$address_A2_Table_Table$address_A2_U256_U256$$()
            // $t9 := pack ERC20MV::State($t11, $t12, $t10, $t0, $t1)
            /// @src 1:2090:2309
            {
                let $mem := $Malloc(160)
                $MemoryStoreU256(add($mem, 64), $t11)
                $MemoryStoreU256(add($mem, 96), $t12)
                $MemoryStoreU256(add($mem, 128), $t10)
                $MemoryStoreU256(add($mem, 0), name)
                $MemoryStoreU256(add($mem, 32), symbol)
                state := $mem
            }
            // $t13 := borrow_local($t9)
            /// @src 1:2363:2373
            $t13 := $MakePtr(false, state)
            // ERC20MV::mint_($t13, $t2, $t3)
            /// @src 1:2357:2408
            A2_ERC20MV_mint_($t13, initial_account, initial_balance)
            // $t14 := move($t9)
            /// @src 1:2418:2423
            $t14 := state
            // return $t14
            /// @src 1:2418:2423
            $result := $t14
        }

        function A2_ERC20MV_mint_(state, account, amount) {
            let mut_bal_account, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15
            // $t4 := 0x0
            /// @src 1:8493:8497
            $t4 := 0x0
            // $t5 := !=($t1, $t4)
            /// @src 1:8490:8492
            /// @src 1:8490:8492
            $t5 := $Neq(account, $t4)
            // $t6 := [69, 82, 67, 50, 48, 58, 32, 109, 105, 110, 116, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
            /// @src 1:8499:8533
            $t6 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(31)))
            $MemoryStoreU64($t6, 31)
            $MemoryStoreU64(add($t6, 8), $ClosestGreaterPowerOfTwo(31))
            copy_literal_string_to_memory_473435132(add($t6, 32))
            // Evm::require($t5, $t6)
            /// @src 1:8474:8534
            A2_Evm_require($t5, $t6)
            // $t7 := borrow_field<ERC20MV::State>.total_supply($t0)
            /// @src 1:8575:8593
            $t7 := $IndexPtr(state, 128)
            // $t8 := read_ref($t7)
            /// @src 1:8575:8593
            $t8 := $LoadU256($t7)
            // $t9 := +($t8, $t2)
            /// @src 1:8565:8602
            $t9 := $AddU256($t8, amount)
            // $t10 := borrow_field<ERC20MV::State>.total_supply($t0)
            /// @src 1:8544:8562
            $t10 := $IndexPtr(state, 128)
            // write_ref($t10, $t9)
            /// @src 1:8544:8602
            $StoreU256($t10, $t9)
            // $t11 := ERC20MV::mut_balanceOf($t0, $t1)
            /// @src 1:8634:8663
            $t11 := A2_ERC20MV_mut_balanceOf(state, account)
            // $t12 := read_ref($t11)
            /// @src 1:8702:8718
            $t12 := $LoadU256($t11)
            // $t13 := +($t12, $t2)
            /// @src 1:8692:8727
            $t13 := $AddU256($t12, amount)
            // write_ref($t11, $t13)
            /// @src 1:8673:8727
            $StoreU256($t11, $t13)
            // $t14 := 0x0
            /// @src 1:8757:8761
            $t14 := 0x0
            // $t15 := pack ERC20MV::Transfer($t14, $t1, $t2)
            /// @src 1:8742:8790
            {
                let $mem := $Malloc(96)
                $MemoryStoreU256(add($mem, 0), $t14)
                $MemoryStoreU256(add($mem, 32), account)
                $MemoryStoreU256(add($mem, 64), amount)
                $t15 := $mem
            }
            // Evm::emit<ERC20MV::Transfer>($t15)
            /// @src 1:8737:8791
            A2_Evm_emit$A2_ERC20MV_Transfer$($t15)
            // return ()
            /// @src 1:8791:8792
        }

        function A2_Evm_emit$A2_ERC20MV_Transfer$(e) {
            let $t1 := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
            let $t2 := $MemoryLoadU256(add(e, 0))
            let $t3 := $MemoryLoadU256(add(e, 32))
            let $t4 := $MemoryLoadU256(add(e, 64))
            {
                let $t5 := mload(0)
                let $t6 := abi_encode_tuple_$uint256$_$A2_U256_U256$($t5, $t4)
                log3($t5, sub($t6, $t5), $t1,$t2,$t3)
                mstore(0, $t6)
            }
        }
        function A2_ERC20MV_mut_balanceOf(state, owner) -> $result {
            let $t2, $t3, $t4, $t5
            let $locals := $Malloc(32)
            mstore($locals, owner)
            // $t2 := borrow_field<ERC20MV::State>.balances($t0)
            /// @src 1:8250:8269
            $t2 := $IndexPtr(state, 64)
            // $t3 := borrow_local($t1)
            /// @src 1:8271:8277
            $t3 := $MakePtr(false, $locals)
            // $t4 := U256::zero()
            /// @src 1:8279:8291
            $t4 := A2_U256_zero()
            // $t5 := Table::borrow_mut_with_default<address, U256::U256>($t2, $t3, $t4)
            /// @src 1:8219:8292
            $t5 := A2_Table_borrow_mut_with_default$address_A2_U256_U256$($t2, $t3, $t4)
            // return $t5
            /// @src 1:8219:8292
            $result := $t5
            $Free($locals, 32)
        }

        function A2_Table_borrow_mut_with_default$address_A2_U256_U256$(table, key, default_value) -> $result {
            let tmp_$3, $t4, $t5, $t6, $t7
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // Table::insert<#0, #1>($t0, $t1, $t2)
                    /// @src 3:903:936
                    A2_Table_insert$address_A2_U256_U256$(table, key, default_value)
                    // goto L0
                    /// @src 3:967:972
                    $block := 3
                }
                case 3 {
                    // label L0
                    // $t7 := Table::borrow_mut<#0, #1>($t0, $t1)
                    /// @src 3:956:978
                    $t7 := A2_Table_borrow_mut$address_A2_U256_U256$(table, key)
                    // return $t7
                    /// @src 3:956:978
                    $result := $t7
                    leave
                }
                case 4 {
                    // $t4 := freeze_ref($t0)
                    /// @src 3:875:887
                    $t4 := table
                    // $t5 := Table::contains<#0, #1>($t4, $t1)
                    /// @src 3:867:887
                    $t5 := A2_Table_contains$address_A2_U256_U256$($t4, key)
                    // $t6 := !($t5)
                    /// @src 3:866:867
                    $t6 := $LogicalNot($t5)
                    // if ($t6) goto L1 else goto L0
                    /// @src 3:862:946
                    switch $t6
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function A2_Table_contains$address_A2_U256_U256$(table_ref, key_ref) -> res {
            let key := $LoadU256(key_ref)
            let table_handle := $LoadU256(table_ref)
            let storage_key := $StorageKey(table_handle, key)
            let word := sload(storage_key)
            res := $LogicalNot(iszero(word))
        }
        function A2_Table_borrow_mut$address_A2_U256_U256$(table_ref, key_ref) -> value_ref {
            let key := $LoadU256(key_ref)
            let table_handle := $LoadU256(table_ref)
            let storage_key := $StorageKey(table_handle, key)
            let value_offs := sload(storage_key)
            if iszero(value_offs) {
              $AbortBuiltin()
            }
            value_ref := $MakePtr(true, value_offs)
        }
        function A2_Table_insert$address_A2_U256_U256$(table_ref, key_ref, value) {
            let key := $LoadU256(key_ref)
            let table_handle := $LoadU256(table_ref)
            let storage_key := $StorageKey(table_handle, key)
            let word := sload(storage_key)
            if $LogicalNot(iszero(word)) {
              $AbortBuiltin()
            }
            let $linked_dst_2934085429 := $NewLinkedStorageBase(0xaee29735)
            $StorageStoreU256($linked_dst_2934085429, value)
            sstore(storage_key, $linked_dst_2934085429)
        }
        function A2_U256_zero() -> $result {
            let $t0
            // $t0 := 0
            /// @src 2:991:1012
            $t0 := 0
            // return $t0
            /// @src 2:991:1012
            $result := $t0
        }

        function A2_Evm_require(cond, message) {
            let $t2
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // Evm::abort_with($t1)
                    /// @src 4:3469:3488
                    A2_Evm_abort_with(message)
                    // goto L0
                    /// @src 4:3456:3491
                    $block := 3
                }
                case 3 {
                    // label L0
                    // return ()
                    /// @src 4:3456:3491
                    leave
                }
                case 4 {
                    // $t2 := !($t0)
                    /// @src 4:3460:3461
                    $t2 := $LogicalNot(cond)
                    // if ($t2) goto L1 else goto L0
                    /// @src 4:3456:3491
                    switch $t2
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function A2_Evm_abort_with(message) {
          let head := $Malloc(32)
          // store the function selector for Error(string)
          mstore(head, 3963877391197344453575983046348115674221700746820753546331534351508065746944)
          let pos := add(head, 4)
          mstore(pos, 32)
          pos := add(pos, 32)
          let size := $MemoryLoadU64(message)
          mstore(pos, size)
          pos := add(pos, 32)
          $CopyMemory(add(message, 32), pos, size)
          size := $RoundUp(size)
          let end := add(pos, size)
          revert(head, sub(end, head))
        }
        function A2_Table_empty$address_A2_Table_Table$address_A2_U256_U256$$() -> table {
            table := $NewTableHandle()
        }
        function A2_Table_empty$address_A2_U256_U256$() -> table {
            table := $NewTableHandle()
        }
        function abi_encode_tuple_$uint256$_$A2_U256_U256$(headStart ,value_0) -> tail {
            tail := add(headStart, 32)
            abi_encode_uint256(value_0, add(headStart, 0))
        }
        function abi_encode_uint256(value, pos) {
            mstore(pos, cleanup_uint256(value))
        }
        function cleanup_uint256(value) -> cleaned {
            cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
        }
        function copy_literal_string_to_memory_473435132(value) {
            $MemoryStoreU8(value, 69)
            value := add(value, 1)
            $MemoryStoreU8(value, 82)
            value := add(value, 1)
            $MemoryStoreU8(value, 67)
            value := add(value, 1)
            $MemoryStoreU8(value, 50)
            value := add(value, 1)
            $MemoryStoreU8(value, 48)
            value := add(value, 1)
            $MemoryStoreU8(value, 58)
            value := add(value, 1)
            $MemoryStoreU8(value, 32)
            value := add(value, 1)
            $MemoryStoreU8(value, 109)
            value := add(value, 1)
            $MemoryStoreU8(value, 105)
            value := add(value, 1)
            $MemoryStoreU8(value, 110)
            value := add(value, 1)
            $MemoryStoreU8(value, 116)
            value := add(value, 1)
            $MemoryStoreU8(value, 32)
            value := add(value, 1)
            $MemoryStoreU8(value, 116)
            value := add(value, 1)
            $MemoryStoreU8(value, 111)
            value := add(value, 1)
            $MemoryStoreU8(value, 32)
            value := add(value, 1)
            $MemoryStoreU8(value, 116)
            value := add(value, 1)
            $MemoryStoreU8(value, 104)
            value := add(value, 1)
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 32)
            value := add(value, 1)
            $MemoryStoreU8(value, 122)
            value := add(value, 1)
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 111)
            value := add(value, 1)
            $MemoryStoreU8(value, 32)
            value := add(value, 1)
            $MemoryStoreU8(value, 97)
            value := add(value, 1)
            $MemoryStoreU8(value, 100)
            value := add(value, 1)
            $MemoryStoreU8(value, 100)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 115)
            value := add(value, 1)
            $MemoryStoreU8(value, 115)
            value := add(value, 1)
        }
        function abi_decode_tuple_$string_string_address_uint256$_$vec$u8$_vec$u8$_address_A2_U256_U256$_from_memory(headStart, dataEnd) -> value_0, value_1, value_2, value_3 {
            if slt(sub(dataEnd, headStart), 128) { $Abort(96) }
            {
                let offset := mload(add(headStart, 0))
                if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                value_0 := abi_decode_string_vec$u8$_from_memory(add(headStart, offset), dataEnd)
            }
            {
                let offset := mload(add(headStart, 32))
                if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                value_1 := abi_decode_string_vec$u8$_from_memory(add(headStart, offset), dataEnd)
            }
            {
                let offset := 64
                value_2 := abi_decode_address_from_memory(add(headStart, offset), dataEnd)
            }
            {
                let offset := 96
                value_3 := abi_decode_uint256_from_memory(add(headStart, offset), dataEnd)
            }
        }
        function abi_decode_uint256_from_memory(offset, end) -> value {
            value := mload(offset)
            validator_uint256(value)
        }
        function validator_uint256(value) {
            if iszero(eq(value, cleanup_uint256(value))) { $Abort(95) }
        }
        function abi_decode_address_from_memory(offset, end) -> value {
            value := mload(offset)
            validator_address(value)
        }
        function validator_address(value) {
            if iszero(eq(value, cleanup_address(value))) { $Abort(95) }
        }
        function cleanup_address(value) -> cleaned {
            cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
        }
        function abi_decode_string_vec$u8$_from_memory(offset, end) -> array {
            if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
            let length := mload(offset)
            let size := add(mul(1, length), 32)
            array := abi_decode_available_length__string_from_memory(add(offset, 0x20), length, size, end)
        }
        function abi_decode_available_length__string_from_memory(src, length, size, end) -> array {
            array := $Malloc($CheckMemorySize(size))
            $MemoryStoreU64(array, length)
            $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
            let dst := add(array, 32)
            if gt(add(src, sub(size, 32)), end) { $Abort(93) }
            $CopyFromMemoryToMemory(src, dst, length)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {}
        function $MakePtr(is_storage, offs) -> ptr {
            ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
            b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
            offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
            mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
            switch size
            case 1 {
                // use the faster byte primitive
                bytes := byte(start, word)
            }
            default {
                // As we have big endian, we need to right shift the value from
                // where the highest byte starts in the word (32 - start), minus
                // the size.
                let shift_bits := shl(3, sub(sub(32, start), size))
                bytes := and(shr(shift_bits, word), $MaskForSize(size))
            }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
            let shift_bits := shl(3, sub(sub(32, start), size))
            // Blend out the bits which we inject
            let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
            word := and(word, neg_mask)
            // Overlay the bits we inject
            new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
            word_offs := shr(5, offs)
            byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
            let available_bytes := sub(32, byte_offset)
            switch gt(size, available_bytes)
            case 0 {
                overflow_bytes := 0
            }
            default {
                overflow_bytes := sub(size, available_bytes)
            }
        }
        function $MemoryLoadBytes(offs, size) -> val {
            // Lower bit where the value in the higher bytes ends
            let bit_end := shl(3, sub(32, size))
            val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
            let bit_end := shl(3, sub(32, size))
            let mask := shl(bit_end, $MaskForSize(size))
            mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
            let word_offs, byte_offs := $ToWordOffs(offs)
            let key := $StorageKey(0, word_offs)
            val := $ExtractBytes(sload(key), byte_offs, size)
            let overflow_bytes := $OverflowBytes(byte_offs, size)
            if $LogicalNot(iszero(overflow_bytes)) {
                key := $StorageKey(0, add(word_offs, 1))
                let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
                val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
            }
        }
        function $StorageStoreBytes(offs, size, bytes) {
            let word_offs, byte_offs := $ToWordOffs(offs)
            let key := $StorageKey(0, word_offs)
            let overflow_bytes := $OverflowBytes(byte_offs, size)
            switch overflow_bytes
            case 0 {
                sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
            }
            default {
                // Shift the higher bytes to the right
                let used_bytes := sub(size, overflow_bytes)
                let higher_bytes := shr(used_bytes, bytes)
                let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
                sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
                key := $StorageKey(0, add(word_offs, 1))
                sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
            }
        }
        function $StorageKey(group, word) -> key {
            mstore(32, word)
            mstore(64, shl(224, group))
            key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
            offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
            let key := $StorageKey(1, 1)
            let handle := sload(key)
            sstore(key, add(handle, 1))
            offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
            new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $NewTableHandle() -> handle {
            let key := $StorageKey(1, 0)
            handle := sload(key)
            if iszero(handle) {
                // no tables have been allocated in this contract, need to initialize the counter
                // to the number of storage groups already statically allocated
                handle := 2
            }
            sstore(key, add(handle, 1))
        }

        function $MemoryStoreU8(offs, val) {
            // Shortcut via special instruction
            mstore8(offs, val)
        }
        function $MemoryLoadU64(offs) -> val {
            val := $MemoryLoadBytes(offs, 8)
        }
        function $MemoryStoreU64(offs, val) {
            $MemoryStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
            let offs := $OffsetPtr(ptr)
            switch $IsStoragePtr(ptr)
            case 0 {
                val := $MemoryLoadU256(offs)
            }
            default {
                val := $StorageLoadU256(offs)
            }
        }
        function $MemoryLoadU256(offs) -> val {
            val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
            val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
            let offs := $OffsetPtr(ptr)
            switch $IsStoragePtr(ptr)
            case 0 {
                $MemoryStoreU256(offs, val)
            }
            default {
                $StorageStoreU256(offs, val)
            }
        }
        function $MemoryStoreU256(offs, val) {
            $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
            $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
            let word_offs := shr(5, offs)
            val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
            let word_offs := shr(5, offs)
            sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
            let num_words, overflow_bytes := $ToWordOffs(size)
            let i := 0
            for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
                mstore(add(dst, i), mload(add(src, i)))
            }
            if overflow_bytes {
                let mask := $MaskForSize(sub(32, overflow_bytes))
                let overflow_offs := mul(num_words, 32)
                let dst_word := and(mload(add(dst, overflow_offs)), mask)
                let src_word := and(mload(add(src, overflow_offs)), not(mask))
                mstore(add(dst, overflow_offs), or(dst_word, src_word))
            }
        }
        function $CheckMemorySize(len) -> checked_len {
            if gt(len, 0xffffffffffffffff) { $AbortBuiltin() }
            checked_len := len
        }
        function $CopyFromMemoryToMemory(src, dst, length) {
            let i := 0
            for { } lt(i, length) { i := add(i, 32) }
            {
                mstore(add(dst, i), mload(add(src, i)))
            }
            if gt(i, length)
            {
                // clear end
                mstore(add(dst, length), 0)
            }
        }
        function $AddU256(x, y) -> r {
            if lt(sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $Neq(x, y) -> r {
            r := $LogicalNot(eq(x, y))
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
        function $RoundUp(value) -> result {
            result := and(add(value, 31), not(31))
        }
    }
    object "A2_ERC20MV_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                case 0xa9059cbb
                {
                    // transfer(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_transfer($MakePtr(true, add($base_offset, 32)), param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xdd62ed3e
                {
                    // allowance(address,address)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_address$_$address_address$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_allowance($MakePtr(true, add($base_offset, 32)), param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x095ea7b3
                {
                    // approve(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_approve($MakePtr(true, add($base_offset, 32)), param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x56189cb4
                {
                    // approveInternal(address,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    A2_ERC20MV_approveInternal($MakePtr(true, add($base_offset, 32)), param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x70a08231
                {
                    // balanceOf(address)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$address$_$address$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_balanceOf($MakePtr(true, add($base_offset, 32)), param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x9dc29fac
                {
                    // burn(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    A2_ERC20MV_burn($MakePtr(true, add($base_offset, 32)), param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x06fdde03
                {
                    // name()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_name($MakePtr(true, add($base_offset, 32)))
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$string$_$vec$u8$$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x95d89b41
                {
                    // symbol()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_symbol($MakePtr(true, add($base_offset, 32)))
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$string$_$vec$u8$$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x313ce567
                {
                    // decimals()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := A2_ERC20MV_decimals()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$u8$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xa457c2d7
                {
                    // decreaseAllowance(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_decreaseAllowance($MakePtr(true, add($base_offset, 32)), param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x39509351
                {
                    // increaseAllowance(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_increaseAllowance($MakePtr(true, add($base_offset, 32)), param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x40c10f19
                {
                    // mint(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    A2_ERC20MV_mint($MakePtr(true, add($base_offset, 32)), param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x18160ddd
                {
                    // totalSupply()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_totalSupply($MakePtr(true, add($base_offset, 32)))
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x23b872dd
                {
                    // transferFrom(address,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    let ret_0 := A2_ERC20MV_transferFrom($MakePtr(true, add($base_offset, 32)), param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x222f5be0
                {
                    // transferInternal(address,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(4, calldatasize())
                    let $base_offset := $MakeTypeStorageBase(0, 0x23fd6316, address())
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    A2_ERC20MV_transferInternal($MakePtr(true, add($base_offset, 32)), param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x6f260334
                {
                    // protectionLayer(address,bytes)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_protection_layer(4, calldatasize())
                    let ret_0 := $ProtectionLayer(param_0, param_1)
                    let flag := $Validate()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xa849b24f
                {
                    // storeExternal(uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint256$_$u256$(4, calldatasize())
                    $StoreExternal(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x31941bcb
                {
                    // unstoreExternal(uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint256$_$u256$(4, calldatasize())
                    $UnstoreExternal(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x7ac3c02f
                {
                    // getSigner()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := $Signer()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$address$_$address$(memPos,ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x51789fab
                {
                    // dropRes(uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint256$_$u256$(4, calldatasize())
                    $DropRes(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                default { revert(0, 0) }
            }
            $Abort(97)
            function A2_ERC20MV_transfer(state, to, amount) -> $result {
                let $t3, $t4
                // $t3 := Evm::sender()
                /// @src 1:3654:3662
                $t3 := A2_Evm_sender()
                // ERC20MV::transfer_($t0, $t3, $t1, $t2)
                /// @src 1:3637:3675
                A2_ERC20MV_transfer_(state, $t3, to, amount)
                // $t4 := true
                /// @src 1:3685:3689
                $t4 := true
                // return $t4
                /// @src 1:3685:3689
                $result := $t4
            }

            function A2_ERC20MV_allowance(state, owner, spender) -> $result {
                let $t3, $t4
                // $t3 := ERC20MV::mut_allowance($t0, $t1, $t2)
                /// @src 1:4690:4726
                $t3 := A2_ERC20MV_mut_allowance(state, owner, spender)
                // $t4 := read_ref($t3)
                /// @src 1:4689:4726
                $t4 := $LoadU256($t3)
                // return $t4
                /// @src 1:4689:4726
                $result := $t4
            }

            function A2_ERC20MV_approve(state, spender, amount) -> $result {
                let $t3, $t4
                // $t3 := Evm::sender()
                /// @src 1:4389:4397
                $t3 := A2_Evm_sender()
                // ERC20MV::approve_($t0, $t3, $t1, $t2)
                /// @src 1:4373:4415
                A2_ERC20MV_approve_(state, $t3, spender, amount)
                // $t4 := true
                /// @src 1:4425:4429
                $t4 := true
                // return $t4
                /// @src 1:4425:4429
                $result := $t4
            }

            function A2_ERC20MV_approveInternal(state, owner, spender, value) {
                // ERC20MV::approve_($t0, $t1, $t2, $t3)
                /// @src 1:1640:1678
                A2_ERC20MV_approve_(state, owner, spender, value)
                // return ()
                /// @src 1:1640:1678
            }

            function A2_ERC20MV_balanceOf(state, owner) -> $result {
                let $t2, $t3
                // $t2 := ERC20MV::mut_balanceOf($t0, $t1)
                /// @src 1:3376:3403
                $t2 := A2_ERC20MV_mut_balanceOf(state, owner)
                // $t3 := read_ref($t2)
                /// @src 1:3375:3403
                $t3 := $LoadU256($t2)
                // return $t3
                /// @src 1:3375:3403
                $result := $t3
            }

            function A2_ERC20MV_burn(state, account, amount) {
                // ERC20MV::burn_($t0, $t1, $t2)
                /// @src 1:1222:1251
                A2_ERC20MV_burn_(state, account, amount)
                // return ()
                /// @src 1:1222:1251
            }

            function A2_ERC20MV_name(state) -> $result {
                let $t1, $t2
                // $t1 := borrow_field<ERC20MV::State>.name($t0)
                /// @src 1:2580:2590
                $t1 := state
                // $t2 := read_ref($t1)
                /// @src 1:2580:2590
                $t2 := $LoadU256($t1)
                if $IsStoragePtr($t1){
                    let $storage_ptr_2300595445
                    let $size_2300595445 := $StorageLoadU64($t2)
                    let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                    $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                    let $data_size_2300595445 := mul($size_2300595445, 1)
                    mstore($storage_ptr_2300595445, $AlignedStorageLoad($t2))
                    $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                    let $data_src_2300595445 := add($t2, 32)
                    let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                    for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                        mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                    }
                    $t2 := $storage_ptr_2300595445
                }
                // return $t2
                /// @src 1:2580:2590
                $result := $t2
            }

            function A2_ERC20MV_symbol(state) -> $result {
                let $t1, $t2
                // $t1 := borrow_field<ERC20MV::State>.symbol($t0)
                /// @src 1:2793:2805
                $t1 := $IndexPtr(state, 32)
                // $t2 := read_ref($t1)
                /// @src 1:2793:2805
                $t2 := $LoadU256($t1)
                if $IsStoragePtr($t1){
                    let $storage_ptr_2300595445
                    let $size_2300595445 := $StorageLoadU64($t2)
                    let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                    $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                    let $data_size_2300595445 := mul($size_2300595445, 1)
                    mstore($storage_ptr_2300595445, $AlignedStorageLoad($t2))
                    $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                    let $data_src_2300595445 := add($t2, 32)
                    let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                    for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                        mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                    }
                    $t2 := $storage_ptr_2300595445
                }
                // return $t2
                /// @src 1:2793:2805
                $result := $t2
            }

            function A2_ERC20MV_decimals() -> $result {
                let $t0
                // $t0 := 18
                /// @src 1:2986:2988
                $t0 := 18
                // return $t0
                /// @src 1:2986:2988
                $result := $t0
            }

            function A2_ERC20MV_decreaseAllowance(state, spender, subtractedValue) -> $result {
                let currentAllowance, owner, $t5, $t6, $t7, $t8, $t9, $t10
                // $t5 := Evm::sender()
                /// @src 1:5440:5448
                $t5 := A2_Evm_sender()
                // $t6 := ERC20MV::allowance($t0, $t5, $t1)
                /// @src 1:5481:5513
                $t6 := A2_ERC20MV_allowance(state, $t5, spender)
                // $t7 := >=($t6, $t2)
                /// @src 1:5531:5574
                $t7 := $GtEq($t6, subtractedValue)
                // $t8 := [69, 82, 67, 50, 48, 58, 32, 100, 101, 99, 114, 101, 97, 115, 101, 100, 32, 97, 108, 108, 111, 119, 97, 110, 99, 101, 32, 98, 101, 108, 111, 119, 32, 122, 101, 114, 111]
                /// @src 1:5576:5616
                $t8 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(37)))
                $MemoryStoreU64($t8, 37)
                $MemoryStoreU64(add($t8, 8), $ClosestGreaterPowerOfTwo(37))
                copy_literal_string_to_memory_4151751928(add($t8, 32))
                // Evm::require($t7, $t8)
                /// @src 1:5523:5617
                A2_Evm_require($t7, $t8)
                // $t9 := -($t6, $t2)
                /// @src 1:5659:5703
                $t9 := $Sub($t6, subtractedValue)
                // ERC20MV::approve_($t0, $t5, $t1, $t9)
                /// @src 1:5627:5704
                A2_ERC20MV_approve_(state, $t5, spender, $t9)
                // $t10 := true
                /// @src 1:5714:5718
                $t10 := true
                // return $t10
                /// @src 1:5714:5718
                $result := $t10
            }

            function A2_ERC20MV_increaseAllowance(state, spender, addedValue) -> $result {
                let increased, owner, $t5, $t6, $t7, $t8
                // $t5 := Evm::sender()
                /// @src 1:5003:5011
                $t5 := A2_Evm_sender()
                // $t6 := ERC20MV::allowance($t0, $t5, $t1)
                /// @src 1:5047:5079
                $t6 := A2_ERC20MV_allowance(state, $t5, spender)
                // $t7 := +($t6, $t2)
                /// @src 1:5037:5092
                $t7 := $AddU256($t6, addedValue)
                // ERC20MV::approve_($t0, $t5, $t1, $t7)
                /// @src 1:5102:5144
                A2_ERC20MV_approve_(state, $t5, spender, $t7)
                // $t8 := true
                /// @src 1:5154:5158
                $t8 := true
                // return $t8
                /// @src 1:5154:5158
                $result := $t8
            }

            function A2_ERC20MV_mint(state, account, amount) {
                // ERC20MV::mint_($t0, $t1, $t2)
                /// @src 1:1058:1087
                A2_ERC20MV_mint_(state, account, amount)
                // return ()
                /// @src 1:1058:1087
            }

            function A2_ERC20MV_totalSupply(state) -> $result {
                let $t1, $t2
                // $t1 := borrow_field<ERC20MV::State>.total_supply($t0)
                /// @src 1:3163:3181
                $t1 := $IndexPtr(state, 128)
                // $t2 := read_ref($t1)
                /// @src 1:3163:3181
                $t2 := $LoadU256($t1)
                // return $t2
                /// @src 1:3163:3181
                $result := $t2
            }

            function A2_ERC20MV_transferFrom(state, from, to, amount) -> $result {
                let $t4, $t5
                // $t4 := Evm::sender()
                /// @src 1:4041:4049
                $t4 := A2_Evm_sender()
                // ERC20MV::spendAllowance_($t0, $t1, $t4, $t3)
                /// @src 1:4012:4058
                A2_ERC20MV_spendAllowance_(state, from, $t4, amount)
                // ERC20MV::transfer_($t0, $t1, $t2, $t3)
                /// @src 1:4068:4102
                A2_ERC20MV_transfer_(state, from, to, amount)
                // $t5 := true
                /// @src 1:4112:4116
                $t5 := true
                // return $t5
                /// @src 1:4112:4116
                $result := $t5
            }

            function A2_ERC20MV_transferInternal(state, from, to, value) {
                // ERC20MV::transfer_($t0, $t1, $t2, $t3)
                /// @src 1:1427:1460
                A2_ERC20MV_transfer_(state, from, to, value)
                // return ()
                /// @src 1:1427:1460
            }

            function $ProtectionLayer(protected_contract, cb) -> result{
                $AbortProtected()
                $Protect()
                $SaveSigner()
                $SaveProtectedContract(protected_contract)
                result := call(gas(), protected_contract, 0, add(cb, 0x20), mload(cb), 0, 0)
                if iszero(result) { revert(0, 0) }
                $Release()
                $DeleteSigner()
                $DeleteProtectedContract()
            }
            function $StoreExternal(resource_id) {
                $AbortNotProtected()
                $DecrementH()
                let sender := caller()
                let hash := $ComputeHash(sender, resource_id)
                let resource
                let type_hash := $GetTypeHash(resource_id)
            }
            function $UnstoreExternal(resource_id) {
                $AbortNotProtected()
                $IncrementH()
                let sender := caller()
                let hash := $ComputeHash(sender, resource_id)
                let resource
                let type_hash := $GetTypeHash(resource_id)
            }
            function $Signer() -> signer{
                $AbortNotProtected()
                signer := $GetSigner()
            }
            function $DropRes(resource_id) {
                $AbortNotProtected()
                $DecrementH()
                let sender := caller()
                let hash := $ComputeHash(sender, resource_id)
                let resource
                let type_hash := $GetTypeHash(resource_id)
            }
            function A2_ERC20MV_transfer_(state, from, to, amount) {
                let from_bal, to_bal, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21
                // $t6 := 0x0
                /// @src 1:7121:7125
                $t6 := 0x0
                // $t7 := !=($t1, $t6)
                /// @src 1:7118:7120
                /// @src 1:7118:7120
                $t7 := $Neq(from, $t6)
                // $t8 := [69, 82, 67, 50, 48, 58, 32, 116, 114, 97, 110, 115, 102, 101, 114, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:7127:7167
                $t8 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(37)))
                $MemoryStoreU64($t8, 37)
                $MemoryStoreU64(add($t8, 8), $ClosestGreaterPowerOfTwo(37))
                copy_literal_string_to_memory_1455811770(add($t8, 32))
                // Evm::require($t7, $t8)
                /// @src 1:7105:7168
                A2_Evm_require($t7, $t8)
                // $t9 := 0x0
                /// @src 1:7192:7196
                $t9 := 0x0
                // $t10 := !=($t2, $t9)
                /// @src 1:7189:7191
                /// @src 1:7189:7191
                $t10 := $Neq(to, $t9)
                // $t11 := [69, 82, 67, 50, 48, 58, 32, 116, 114, 97, 110, 115, 102, 101, 114, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:7198:7236
                $t11 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(35)))
                $MemoryStoreU64($t11, 35)
                $MemoryStoreU64(add($t11, 8), $ClosestGreaterPowerOfTwo(35))
                copy_literal_string_to_memory_283268869(add($t11, 32))
                // Evm::require($t10, $t11)
                /// @src 1:7178:7237
                A2_Evm_require($t10, $t11)
                // $t12 := ERC20MV::mut_balanceOf($t0, $t1)
                /// @src 1:7262:7288
                $t12 := A2_ERC20MV_mut_balanceOf(state, from)
                // $t13 := read_ref($t12)
                /// @src 1:7323:7332
                $t13 := $LoadU256($t12)
                // $t14 := <=($t3, $t13)
                /// @src 1:7306:7333
                $t14 := $LtEq(amount, $t13)
                // $t15 := [69, 82, 67, 50, 48, 58, 32, 116, 114, 97, 110, 115, 102, 101, 114, 32, 97, 109, 111, 117, 110, 116, 32, 101, 120, 99, 101, 101, 100, 115, 32, 98, 97, 108, 97, 110, 99, 101]
                /// @src 1:7335:7376
                $t15 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(38)))
                $MemoryStoreU64($t15, 38)
                $MemoryStoreU64(add($t15, 8), $ClosestGreaterPowerOfTwo(38))
                copy_literal_string_to_memory_2833778497(add($t15, 32))
                // Evm::require($t14, $t15)
                /// @src 1:7298:7377
                A2_Evm_require($t14, $t15)
                // $t16 := read_ref($t12)
                /// @src 1:7409:7418
                $t16 := $LoadU256($t12)
                // $t17 := -($t16, $t3)
                /// @src 1:7399:7427
                $t17 := $Sub($t16, amount)
                // write_ref($t12, $t17)
                /// @src 1:7387:7427
                $StoreU256($t12, $t17)
                // $t18 := ERC20MV::mut_balanceOf($t0, $t2)
                /// @src 1:7450:7474
                $t18 := A2_ERC20MV_mut_balanceOf(state, to)
                // $t19 := read_ref($t18)
                /// @src 1:7504:7511
                $t19 := $LoadU256($t18)
                // $t20 := +($t19, $t3)
                /// @src 1:7494:7525
                $t20 := $AddU256($t19, amount)
                // write_ref($t18, $t20)
                /// @src 1:7484:7525
                $StoreU256($t18, $t20)
                // $t21 := pack ERC20MV::Transfer($t1, $t2, $t3)
                /// @src 1:7540:7573
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), from)
                    $MemoryStoreU256(add($mem, 32), to)
                    $MemoryStoreU256(add($mem, 64), amount)
                    $t21 := $mem
                }
                // Evm::emit<ERC20MV::Transfer>($t21)
                /// @src 1:7535:7574
                A2_Evm_emit$A2_ERC20MV_Transfer$($t21)
                // return ()
                /// @src 1:7574:7575
            }

            function A2_Evm_emit$A2_ERC20MV_Transfer$(e) {
                let $t1 := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := $MemoryLoadU256(add(e, 64))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$uint256$_$A2_U256_U256$($t5, $t4)
                    log3($t5, sub($t6, $t5), $t1,$t2,$t3)
                    mstore(0, $t6)
                }
            }
            function A2_ERC20MV_mut_balanceOf(state, owner) -> $result {
                let $t2, $t3, $t4, $t5
                let $locals := $Malloc(32)
                mstore($locals, owner)
                // $t2 := borrow_field<ERC20MV::State>.balances($t0)
                /// @src 1:8250:8269
                $t2 := $IndexPtr(state, 64)
                // $t3 := borrow_local($t1)
                /// @src 1:8271:8277
                $t3 := $MakePtr(false, $locals)
                // $t4 := U256::zero()
                /// @src 1:8279:8291
                $t4 := A2_U256_zero()
                // $t5 := Table::borrow_mut_with_default<address, U256::U256>($t2, $t3, $t4)
                /// @src 1:8219:8292
                $t5 := A2_Table_borrow_mut_with_default$address_A2_U256_U256$($t2, $t3, $t4)
                // return $t5
                /// @src 1:8219:8292
                $result := $t5
                $Free($locals, 32)
            }

            function A2_Table_borrow_mut_with_default$address_A2_U256_U256$(table, key, default_value) -> $result {
                let tmp_$3, $t4, $t5, $t6, $t7
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L1
                        // Table::insert<#0, #1>($t0, $t1, $t2)
                        /// @src 3:903:936
                        A2_Table_insert$address_A2_U256_U256$(table, key, default_value)
                        // goto L0
                        /// @src 3:967:972
                        $block := 3
                    }
                    case 3 {
                        // label L0
                        // $t7 := Table::borrow_mut<#0, #1>($t0, $t1)
                        /// @src 3:956:978
                        $t7 := A2_Table_borrow_mut$address_A2_U256_U256$(table, key)
                        // return $t7
                        /// @src 3:956:978
                        $result := $t7
                        leave
                    }
                    case 4 {
                        // $t4 := freeze_ref($t0)
                        /// @src 3:875:887
                        $t4 := table
                        // $t5 := Table::contains<#0, #1>($t4, $t1)
                        /// @src 3:867:887
                        $t5 := A2_Table_contains$address_A2_U256_U256$($t4, key)
                        // $t6 := !($t5)
                        /// @src 3:866:867
                        $t6 := $LogicalNot($t5)
                        // if ($t6) goto L1 else goto L0
                        /// @src 3:862:946
                        switch $t6
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function A2_Table_contains$address_A2_U256_U256$(table_ref, key_ref) -> res {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                res := $LogicalNot(iszero(word))
            }
            function A2_Table_borrow_mut$address_A2_U256_U256$(table_ref, key_ref) -> value_ref {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let value_offs := sload(storage_key)
                if iszero(value_offs) {
                  $AbortBuiltin()
                }
                value_ref := $MakePtr(true, value_offs)
            }
            function A2_Table_insert$address_A2_U256_U256$(table_ref, key_ref, value) {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                if $LogicalNot(iszero(word)) {
                  $AbortBuiltin()
                }
                let $linked_dst_2934085429 := $NewLinkedStorageBase(0xaee29735)
                $StorageStoreU256($linked_dst_2934085429, value)
                sstore(storage_key, $linked_dst_2934085429)
            }
            function A2_U256_zero() -> $result {
                let $t0
                // $t0 := 0
                /// @src 2:991:1012
                $t0 := 0
                // return $t0
                /// @src 2:991:1012
                $result := $t0
            }

            function A2_Evm_require(cond, message) {
                let $t2
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L1
                        // Evm::abort_with($t1)
                        /// @src 4:3469:3488
                        A2_Evm_abort_with(message)
                        // goto L0
                        /// @src 4:3456:3491
                        $block := 3
                    }
                    case 3 {
                        // label L0
                        // return ()
                        /// @src 4:3456:3491
                        leave
                    }
                    case 4 {
                        // $t2 := !($t0)
                        /// @src 4:3460:3461
                        $t2 := $LogicalNot(cond)
                        // if ($t2) goto L1 else goto L0
                        /// @src 4:3456:3491
                        switch $t2
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function A2_Evm_abort_with(message) {
              let head := $Malloc(32)
              // store the function selector for Error(string)
              mstore(head, 3963877391197344453575983046348115674221700746820753546331534351508065746944)
              let pos := add(head, 4)
              mstore(pos, 32)
              pos := add(pos, 32)
              let size := $MemoryLoadU64(message)
              mstore(pos, size)
              pos := add(pos, 32)
              $CopyMemory(add(message, 32), pos, size)
              size := $RoundUp(size)
              let end := add(pos, size)
              revert(head, sub(end, head))
            }
            function A2_ERC20MV_spendAllowance_(state, owner, spender, amount) {
                let currentAllowance, $t5, $t6, $t7, $t8, $t9, $t10
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L1
                        // $t8 := >=($t5, $t3)
                        /// @src 1:6044:6078
                        $t8 := $GtEq($t5, amount)
                        // $t9 := [69, 82, 67, 50, 48, 58, 32, 105, 110, 115, 117, 102, 102, 105, 99, 105, 101, 110, 116, 32, 97, 108, 108, 111, 119, 97, 110, 99, 101]
                        /// @src 1:6080:6112
                        $t9 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(29)))
                        $MemoryStoreU64($t9, 29)
                        $MemoryStoreU64(add($t9, 8), $ClosestGreaterPowerOfTwo(29))
                        copy_literal_string_to_memory_3758581307(add($t9, 32))
                        // Evm::require($t8, $t9)
                        /// @src 1:6036:6113
                        A2_Evm_require($t8, $t9)
                        // $t10 := -($t5, $t3)
                        /// @src 1:6159:6194
                        $t10 := $Sub($t5, amount)
                        // ERC20MV::approve_($t0, $t1, $t2, $t10)
                        /// @src 1:6127:6195
                        A2_ERC20MV_approve_(state, owner, spender, $t10)
                        // goto L2
                        /// @src 1:5985:6206
                        $block := 5
                    }
                    case 3 {
                        // label L0
                        // destroy($t0)
                        /// @src 1:5985:6206
                        // goto L2
                        /// @src 1:5985:6206
                        $block := 5
                    }
                    case 4 {
                        // $t5 := ERC20MV::allowance($t0, $t1, $t2)
                        /// @src 1:5943:5975
                        $t5 := A2_ERC20MV_allowance(state, owner, spender)
                        // $t6 := U256::max()
                        /// @src 1:6009:6020
                        $t6 := A2_U256_max()
                        // $t7 := !=($t5, $t6)
                        /// @src 1:6006:6008
                        /// @src 1:6006:6008
                        $t7 := $Neq($t5, $t6)
                        // if ($t7) goto L1 else goto L0
                        /// @src 1:5985:6206
                        switch $t7
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                    case 5 {
                        // label L2
                        // return ()
                        /// @src 1:5985:6206
                        leave
                    }
                }
            }

            function A2_U256_max() -> $result {
                let $t0
                // $t0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
                /// @src 2:1123:1158
                $t0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
                // return $t0
                /// @src 2:1123:1158
                $result := $t0
            }

            function A2_ERC20MV_approve_(state, owner, spender, amount) {
                let tmp_$4, a, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33
                let $locals := $Malloc(64)
                mstore($locals, owner)
                mstore(add($locals, 32), spender)
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L1
                        // $t18 := borrow_field<ERC20MV::State>.allowances($t0)
                        /// @src 1:6577:6598
                        $t18 := $IndexPtr(state, 96)
                        // $t19 := borrow_local($t1)
                        /// @src 1:6600:6606
                        $t19 := $MakePtr(false, $locals)
                        // $t20 := Table::empty<address, U256::U256>()
                        /// @src 1:6608:6637
                        $t20 := A2_Table_empty$address_A2_U256_U256$()
                        // Table::insert<address, Table::Table<address, U256::U256>>($t18, $t19, $t20)
                        /// @src 1:6563:6638
                        A2_Table_insert$address_A2_Table_Table$address_A2_U256_U256$$($t18, $t19, $t20)
                        // goto L0
                        /// @src 1:6689:6694
                        $block := 3
                    }
                    case 3 {
                        // label L0
                        // $t21 := borrow_field<ERC20MV::State>.allowances($t0)
                        /// @src 1:6684:6705
                        $t21 := $IndexPtr(state, 96)
                        // $t22 := borrow_local($t1)
                        /// @src 1:6707:6713
                        $t22 := $MakePtr(false, $locals)
                        // $t23 := Table::borrow_mut<address, Table::Table<address, U256::U256>>($t21, $t22)
                        /// @src 1:6666:6714
                        $t23 := A2_Table_borrow_mut$address_A2_Table_Table$address_A2_U256_U256$$($t21, $t22)
                        // $t24 := borrow_local($t2)
                        /// @src 1:6747:6755
                        $t24 := $MakePtr(false, add($locals, 32))
                        // $t25 := freeze_ref($t23)
                        /// @src 1:6743:6756
                        $t25 := $t23
                        // $t26 := Table::contains<address, U256::U256>($t25, $t24)
                        /// @src 1:6728:6756
                        $t26 := A2_Table_contains$address_A2_U256_U256$($t25, $t24)
                        // $t27 := !($t26)
                        /// @src 1:6727:6728
                        $t27 := $LogicalNot($t26)
                        // if ($t27) goto L3 else goto L2
                        /// @src 1:6724:6896
                        switch $t27
                        case 0  { $block := 6 }
                        default { $block := 5 }
                    }
                    case 4 {
                        // $t6 := copy($t1)
                        /// @src 1:6363:6368
                        $t6 := mload($locals)
                        // $t7 := 0x0
                        /// @src 1:6372:6376
                        $t7 := 0x0
                        // $t8 := !=($t6, $t7)
                        /// @src 1:6369:6371
                        /// @src 1:6369:6371
                        $t8 := $Neq($t6, $t7)
                        // $t9 := [69, 82, 67, 50, 48, 58, 32, 97, 112, 112, 114, 111, 118, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                        /// @src 1:6378:6417
                        $t9 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(36)))
                        $MemoryStoreU64($t9, 36)
                        $MemoryStoreU64(add($t9, 8), $ClosestGreaterPowerOfTwo(36))
                        copy_literal_string_to_memory_2280936393(add($t9, 32))
                        // Evm::require($t8, $t9)
                        /// @src 1:6355:6418
                        A2_Evm_require($t8, $t9)
                        // $t10 := copy($t2)
                        /// @src 1:6436:6443
                        $t10 := mload(add($locals, 32))
                        // $t11 := 0x0
                        /// @src 1:6447:6451
                        $t11 := 0x0
                        // $t12 := !=($t10, $t11)
                        /// @src 1:6444:6446
                        /// @src 1:6444:6446
                        $t12 := $Neq($t10, $t11)
                        // $t13 := [69, 82, 67, 50, 48, 58, 32, 97, 112, 112, 114, 111, 118, 101, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                        /// @src 1:6453:6490
                        $t13 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(34)))
                        $MemoryStoreU64($t13, 34)
                        $MemoryStoreU64(add($t13, 8), $ClosestGreaterPowerOfTwo(34))
                        copy_literal_string_to_memory_3309078564(add($t13, 32))
                        // Evm::require($t12, $t13)
                        /// @src 1:6428:6491
                        A2_Evm_require($t12, $t13)
                        // $t14 := borrow_field<ERC20MV::State>.allowances($t0)
                        /// @src 1:6521:6538
                        $t14 := $IndexPtr(state, 96)
                        // $t15 := borrow_local($t1)
                        /// @src 1:6540:6546
                        $t15 := $MakePtr(false, $locals)
                        // $t16 := Table::contains<address, Table::Table<address, U256::U256>>($t14, $t15)
                        /// @src 1:6505:6547
                        $t16 := A2_Table_contains$address_A2_Table_Table$address_A2_U256_U256$$($t14, $t15)
                        // $t17 := !($t16)
                        /// @src 1:6504:6505
                        $t17 := $LogicalNot($t16)
                        // if ($t17) goto L1 else goto L0
                        /// @src 1:6501:6648
                        switch $t17
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                    case 5 {
                        // label L3
                        // $t28 := borrow_local($t2)
                        /// @src 1:6789:6797
                        $t28 := $MakePtr(false, add($locals, 32))
                        // Table::insert<address, U256::U256>($t23, $t28, $t3)
                        /// @src 1:6772:6806
                        A2_Table_insert$address_A2_U256_U256$($t23, $t28, amount)
                        // goto L4
                        /// @src 1:6806:6807
                        $block := 7
                    }
                    case 6 {
                        // label L2
                        // $t29 := borrow_local($t2)
                        /// @src 1:6867:6875
                        $t29 := $MakePtr(false, add($locals, 32))
                        // $t30 := Table::borrow_mut<address, U256::U256>($t23, $t29)
                        /// @src 1:6846:6876
                        $t30 := A2_Table_borrow_mut$address_A2_U256_U256$($t23, $t29)
                        // write_ref($t30, $t3)
                        /// @src 1:6845:6885
                        $StoreU256($t30, amount)
                        // goto L4
                        /// @src 1:6920:6925
                        $block := 7
                    }
                    case 7 {
                        // label L4
                        // $t31 := move($t1)
                        /// @src 1:6920:6925
                        $t31 := mload($locals)
                        // $t32 := move($t2)
                        /// @src 1:6927:6934
                        $t32 := mload(add($locals, 32))
                        // $t33 := pack ERC20MV::Approval($t31, $t32, $t3)
                        /// @src 1:6911:6950
                        {
                            let $mem := $Malloc(96)
                            $MemoryStoreU256(add($mem, 0), $t31)
                            $MemoryStoreU256(add($mem, 32), $t32)
                            $MemoryStoreU256(add($mem, 64), amount)
                            $t33 := $mem
                        }
                        // Evm::emit<ERC20MV::Approval>($t33)
                        /// @src 1:6906:6951
                        A2_Evm_emit$A2_ERC20MV_Approval$($t33)
                        // return ()
                        /// @src 1:6951:6952
                        $Free($locals, 64)
                        leave
                    }
                }
            }

            function A2_Evm_emit$A2_ERC20MV_Approval$(e) {
                let $t1 := 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := $MemoryLoadU256(add(e, 64))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$uint256$_$A2_U256_U256$($t5, $t4)
                    log3($t5, sub($t6, $t5), $t1,$t2,$t3)
                    mstore(0, $t6)
                }
            }
            function A2_Table_contains$address_A2_Table_Table$address_A2_U256_U256$$(table_ref, key_ref) -> res {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                res := $LogicalNot(iszero(word))
            }
            function A2_Table_borrow_mut$address_A2_Table_Table$address_A2_U256_U256$$(table_ref, key_ref) -> value_ref {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let value_offs := sload(storage_key)
                if iszero(value_offs) {
                  $AbortBuiltin()
                }
                value_ref := $MakePtr(true, value_offs)
            }
            function A2_Table_insert$address_A2_Table_Table$address_A2_U256_U256$$(table_ref, key_ref, value) {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                if $LogicalNot(iszero(word)) {
                  $AbortBuiltin()
                }
                let $linked_dst_3228464714 := $NewLinkedStorageBase(0xc06e764a)
                $StorageStoreU256($linked_dst_3228464714, value)
                sstore(storage_key, $linked_dst_3228464714)
            }
            function A2_Table_empty$address_A2_U256_U256$() -> table {
                table := $NewTableHandle()
            }
            function A2_Evm_sender() -> $result {
                let $t0
                // $t0 := Evm::msg_sender()
                /// @src 4:442:454
                $t0 := A2_Evm_msg_sender()
                // return $t0
                /// @src 4:442:454
                $result := $t0
            }

            function A2_Evm_msg_sender() -> result {
              result := caller()
            }
            function A2_ERC20MV_mint_(state, account, amount) {
                let mut_bal_account, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15
                // $t4 := 0x0
                /// @src 1:8493:8497
                $t4 := 0x0
                // $t5 := !=($t1, $t4)
                /// @src 1:8490:8492
                /// @src 1:8490:8492
                $t5 := $Neq(account, $t4)
                // $t6 := [69, 82, 67, 50, 48, 58, 32, 109, 105, 110, 116, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:8499:8533
                $t6 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(31)))
                $MemoryStoreU64($t6, 31)
                $MemoryStoreU64(add($t6, 8), $ClosestGreaterPowerOfTwo(31))
                copy_literal_string_to_memory_473435132(add($t6, 32))
                // Evm::require($t5, $t6)
                /// @src 1:8474:8534
                A2_Evm_require($t5, $t6)
                // $t7 := borrow_field<ERC20MV::State>.total_supply($t0)
                /// @src 1:8575:8593
                $t7 := $IndexPtr(state, 128)
                // $t8 := read_ref($t7)
                /// @src 1:8575:8593
                $t8 := $LoadU256($t7)
                // $t9 := +($t8, $t2)
                /// @src 1:8565:8602
                $t9 := $AddU256($t8, amount)
                // $t10 := borrow_field<ERC20MV::State>.total_supply($t0)
                /// @src 1:8544:8562
                $t10 := $IndexPtr(state, 128)
                // write_ref($t10, $t9)
                /// @src 1:8544:8602
                $StoreU256($t10, $t9)
                // $t11 := ERC20MV::mut_balanceOf($t0, $t1)
                /// @src 1:8634:8663
                $t11 := A2_ERC20MV_mut_balanceOf(state, account)
                // $t12 := read_ref($t11)
                /// @src 1:8702:8718
                $t12 := $LoadU256($t11)
                // $t13 := +($t12, $t2)
                /// @src 1:8692:8727
                $t13 := $AddU256($t12, amount)
                // write_ref($t11, $t13)
                /// @src 1:8673:8727
                $StoreU256($t11, $t13)
                // $t14 := 0x0
                /// @src 1:8757:8761
                $t14 := 0x0
                // $t15 := pack ERC20MV::Transfer($t14, $t1, $t2)
                /// @src 1:8742:8790
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), $t14)
                    $MemoryStoreU256(add($mem, 32), account)
                    $MemoryStoreU256(add($mem, 64), amount)
                    $t15 := $mem
                }
                // Evm::emit<ERC20MV::Transfer>($t15)
                /// @src 1:8737:8791
                A2_Evm_emit$A2_ERC20MV_Transfer$($t15)
                // return ()
                /// @src 1:8791:8792
            }

            function A2_ERC20MV_burn_(state, account, amount) {
                let mut_bal_account, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18
                // $t4 := 0x0
                /// @src 1:8970:8974
                $t4 := 0x0
                // $t5 := !=($t1, $t4)
                /// @src 1:8967:8969
                /// @src 1:8967:8969
                $t5 := $Neq(account, $t4)
                // $t6 := [69, 82, 67, 50, 48, 58, 32, 98, 117, 114, 110, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:8976:9012
                $t6 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(33)))
                $MemoryStoreU64($t6, 33)
                $MemoryStoreU64(add($t6, 8), $ClosestGreaterPowerOfTwo(33))
                copy_literal_string_to_memory_1233676209(add($t6, 32))
                // Evm::require($t5, $t6)
                /// @src 1:8951:9013
                A2_Evm_require($t5, $t6)
                // $t7 := ERC20MV::mut_balanceOf($t0, $t1)
                /// @src 1:9045:9074
                $t7 := A2_ERC20MV_mut_balanceOf(state, account)
                // $t8 := read_ref($t7)
                /// @src 1:9101:9117
                $t8 := $LoadU256($t7)
                // $t9 := >=($t8, $t2)
                /// @src 1:9092:9126
                $t9 := $GtEq($t8, amount)
                // $t10 := [69, 82, 67, 50, 48, 58, 32, 98, 117, 114, 110, 32, 97, 109, 111, 117, 110, 116, 32, 101, 120, 99, 101, 101, 100, 115, 32, 98, 97, 108, 97, 110, 99, 101]
                /// @src 1:9128:9165
                $t10 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(34)))
                $MemoryStoreU64($t10, 34)
                $MemoryStoreU64(add($t10, 8), $ClosestGreaterPowerOfTwo(34))
                copy_literal_string_to_memory_1846713108(add($t10, 32))
                // Evm::require($t9, $t10)
                /// @src 1:9084:9166
                A2_Evm_require($t9, $t10)
                // $t11 := read_ref($t7)
                /// @src 1:9205:9221
                $t11 := $LoadU256($t7)
                // $t12 := -($t11, $t2)
                /// @src 1:9195:9230
                $t12 := $Sub($t11, amount)
                // write_ref($t7, $t12)
                /// @src 1:9176:9230
                $StoreU256($t7, $t12)
                // $t13 := borrow_field<ERC20MV::State>.total_supply($t0)
                /// @src 1:9271:9289
                $t13 := $IndexPtr(state, 128)
                // $t14 := read_ref($t13)
                /// @src 1:9271:9289
                $t14 := $LoadU256($t13)
                // $t15 := -($t14, $t2)
                /// @src 1:9261:9298
                $t15 := $Sub($t14, amount)
                // $t16 := borrow_field<ERC20MV::State>.total_supply($t0)
                /// @src 1:9240:9258
                $t16 := $IndexPtr(state, 128)
                // write_ref($t16, $t15)
                /// @src 1:9240:9298
                $StoreU256($t16, $t15)
                // $t17 := 0x0
                /// @src 1:9341:9345
                $t17 := 0x0
                // $t18 := pack ERC20MV::Transfer($t1, $t17, $t2)
                /// @src 1:9313:9361
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), account)
                    $MemoryStoreU256(add($mem, 32), $t17)
                    $MemoryStoreU256(add($mem, 64), amount)
                    $t18 := $mem
                }
                // Evm::emit<ERC20MV::Transfer>($t18)
                /// @src 1:9308:9362
                A2_Evm_emit$A2_ERC20MV_Transfer$($t18)
                // return ()
                /// @src 1:9362:9363
            }

            function A2_ERC20MV_mut_allowance(state, owner, spender) -> $result {
                let $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15
                let $locals := $Malloc(64)
                mstore($locals, owner)
                mstore(add($locals, 32), spender)
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L1
                        // $t7 := borrow_field<ERC20MV::State>.allowances($t0)
                        /// @src 1:7830:7851
                        $t7 := $IndexPtr(state, 96)
                        // $t8 := borrow_local($t1)
                        /// @src 1:7853:7859
                        $t8 := $MakePtr(false, $locals)
                        // $t9 := Table::empty<address, U256::U256>()
                        /// @src 1:7861:7890
                        $t9 := A2_Table_empty$address_A2_U256_U256$()
                        // Table::insert<address, Table::Table<address, U256::U256>>($t7, $t8, $t9)
                        /// @src 1:7816:7891
                        A2_Table_insert$address_A2_Table_Table$address_A2_U256_U256$$($t7, $t8, $t9)
                        // goto L0
                        /// @src 1:7956:7961
                        $block := 3
                    }
                    case 3 {
                        // label L0
                        // $t10 := borrow_field<ERC20MV::State>.allowances($t0)
                        /// @src 1:7951:7972
                        $t10 := $IndexPtr(state, 96)
                        // $t11 := borrow_local($t1)
                        /// @src 1:7974:7980
                        $t11 := $MakePtr(false, $locals)
                        // $t12 := Table::borrow_mut<address, Table::Table<address, U256::U256>>($t10, $t11)
                        /// @src 1:7933:7981
                        $t12 := A2_Table_borrow_mut$address_A2_Table_Table$address_A2_U256_U256$$($t10, $t11)
                        // $t13 := borrow_local($t2)
                        /// @src 1:8039:8047
                        $t13 := $MakePtr(false, add($locals, 32))
                        // $t14 := U256::zero()
                        /// @src 1:8049:8061
                        $t14 := A2_U256_zero()
                        // $t15 := Table::borrow_mut_with_default<address, U256::U256>($t12, $t13, $t14)
                        /// @src 1:7991:8062
                        $t15 := A2_Table_borrow_mut_with_default$address_A2_U256_U256$($t12, $t13, $t14)
                        // return $t15
                        /// @src 1:7991:8062
                        $result := $t15
                        $Free($locals, 64)
                        leave
                    }
                    case 4 {
                        // $t3 := borrow_field<ERC20MV::State>.allowances($t0)
                        /// @src 1:7774:7791
                        $t3 := $IndexPtr(state, 96)
                        // $t4 := borrow_local($t1)
                        /// @src 1:7793:7799
                        $t4 := $MakePtr(false, $locals)
                        // $t5 := Table::contains<address, Table::Table<address, U256::U256>>($t3, $t4)
                        /// @src 1:7758:7800
                        $t5 := A2_Table_contains$address_A2_Table_Table$address_A2_U256_U256$$($t3, $t4)
                        // $t6 := !($t5)
                        /// @src 1:7757:7758
                        $t6 := $LogicalNot($t5)
                        // if ($t6) goto L1 else goto L0
                        /// @src 1:7754:7901
                        switch $t6
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function copy_literal_string_to_memory_1846713108(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 98)
                value := add(value, 1)
                $MemoryStoreU8(value, 117)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 109)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 117)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 120)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 98)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 108)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_1233676209(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 98)
                value := add(value, 1)
                $MemoryStoreU8(value, 117)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 109)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 104)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 122)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_473435132(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 109)
                value := add(value, 1)
                $MemoryStoreU8(value, 105)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 104)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 122)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
            }
            function abi_encode_tuple_$uint256$_$A2_U256_U256$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint256(value_0, add(headStart, 0))
            }
            function abi_encode_uint256(value, pos) {
                mstore(pos, cleanup_uint256(value))
            }
            function cleanup_uint256(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            }
            function copy_literal_string_to_memory_3309078564(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 112)
                value := add(value, 1)
                $MemoryStoreU8(value, 112)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 118)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 104)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 122)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_2280936393(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 112)
                value := add(value, 1)
                $MemoryStoreU8(value, 112)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 118)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 109)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 104)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 122)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_3758581307(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 105)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 117)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 105)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 105)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 108)
                value := add(value, 1)
                $MemoryStoreU8(value, 108)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 119)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_2833778497(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 109)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 117)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 120)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 98)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 108)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_283268869(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 104)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 122)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_1455811770(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 102)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 109)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 116)
                value := add(value, 1)
                $MemoryStoreU8(value, 104)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 122)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
            }
            function copy_literal_string_to_memory_4151751928(value) {
                $MemoryStoreU8(value, 69)
                value := add(value, 1)
                $MemoryStoreU8(value, 82)
                value := add(value, 1)
                $MemoryStoreU8(value, 67)
                value := add(value, 1)
                $MemoryStoreU8(value, 50)
                value := add(value, 1)
                $MemoryStoreU8(value, 48)
                value := add(value, 1)
                $MemoryStoreU8(value, 58)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 115)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 100)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 108)
                value := add(value, 1)
                $MemoryStoreU8(value, 108)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 119)
                value := add(value, 1)
                $MemoryStoreU8(value, 97)
                value := add(value, 1)
                $MemoryStoreU8(value, 110)
                value := add(value, 1)
                $MemoryStoreU8(value, 99)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 98)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 108)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
                $MemoryStoreU8(value, 119)
                value := add(value, 1)
                $MemoryStoreU8(value, 32)
                value := add(value, 1)
                $MemoryStoreU8(value, 122)
                value := add(value, 1)
                $MemoryStoreU8(value, 101)
                value := add(value, 1)
                $MemoryStoreU8(value, 114)
                value := add(value, 1)
                $MemoryStoreU8(value, 111)
                value := add(value, 1)
            }
            function abi_encode_tuple__(headStart ) -> tail {
                tail := add(headStart, 0)
            }
            function abi_decode_tuple_$uint256$_$u256$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint256(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint256(offset, end) -> value {
                value := calldataload(offset)
                validator_uint256(value)
            }
            function validator_uint256(value) {
                if iszero(eq(value, cleanup_uint256(value))) { $Abort(95) }
            }
            function abi_encode_tuple_$address$_$address$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_address(value_0, add(headStart, 0))
            }
            function abi_encode_address(value, pos) {
                mstore(pos, cleanup_address(value))
            }
            function cleanup_address(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
            }
            function abi_encode_tuple_$bool$_$bool$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_bool(value_0, add(headStart, 0))
            }
            function abi_encode_bool(value, pos) {
                mstore(pos, cleanup_bool(value))
            }
            function cleanup_bool(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 96) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_uint256(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_address(offset, end) -> value {
                value := calldataload(offset)
                validator_address(value)
            }
            function validator_address(value) {
                if iszero(eq(value, cleanup_address(value))) { $Abort(95) }
            }
            function abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_uint256(add(headStart, offset), dataEnd)
                }
            }
            function abi_encode_tuple_$uint8$_$u8$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint8(value_0, add(headStart, 0))
            }
            function abi_encode_uint8(value, pos) {
                mstore(pos, cleanup_uint8(value))
            }
            function cleanup_uint8(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_encode_tuple_$string$_$vec$u8$$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_string(value_0,  tail)
            }
            function abi_encode_string(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                mstore(pos, size)
                pos := add(pos, 0x20)
                $CopyMemory(add(value, 0x20), pos, size)
                size := $RoundUp(size)
                end := add(pos, size)
            }
            function abi_decode_tuple_$address$_$address$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_tuple_$address_address$_$address_address$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_address(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_protection_layer(headStart, dataEnd) -> value0, value1 {
                value0, value1 := $AbiDecodeProtectionLayer(headStart, dataEnd)
            }
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $AbortBuiltin() {
                $Abort(sub(0, 1))
            }
            function $Malloc(size) -> offs {
                offs := mload(0)
                // pad to word size
                mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
            }
            function $Free(offs, size) {}
            function $MakePtr(is_storage, offs) -> ptr {
                ptr := or(is_storage, shl(1, offs))
            }
            function $IsStoragePtr(ptr) -> b {
                b := and(ptr, 0x1)
            }
            function $OffsetPtr(ptr) -> offs {
                offs := shr(1, ptr)
            }
            function $MaskForSize(size) -> mask {
                mask := sub(shl(shl(3, size), 1), 1)
            }
            function $ExtractBytes(word, start, size) -> bytes {
                switch size
                case 1 {
                    // use the faster byte primitive
                    bytes := byte(start, word)
                }
                default {
                    // As we have big endian, we need to right shift the value from
                    // where the highest byte starts in the word (32 - start), minus
                    // the size.
                    let shift_bits := shl(3, sub(sub(32, start), size))
                    bytes := and(shr(shift_bits, word), $MaskForSize(size))
                }
            }
            function $InjectBytes(word, start, size, bytes) -> new_word {
                let shift_bits := shl(3, sub(sub(32, start), size))
                // Blend out the bits which we inject
                let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
                word := and(word, neg_mask)
                // Overlay the bits we inject
                new_word := or(word, shl(shift_bits, bytes))
            }
            function $ToWordOffs(offs) -> word_offs, byte_offset {
                word_offs := shr(5, offs)
                byte_offset := and(offs, 0x1F)
            }
            function $OverflowBytes(byte_offset, size) -> overflow_bytes {
                let available_bytes := sub(32, byte_offset)
                switch gt(size, available_bytes)
                case 0 {
                    overflow_bytes := 0
                }
                default {
                    overflow_bytes := sub(size, available_bytes)
                }
            }
            function $MemoryLoadBytes(offs, size) -> val {
                // Lower bit where the value in the higher bytes ends
                let bit_end := shl(3, sub(32, size))
                val := shr(bit_end, mload(offs))
            }
            function $MemoryStoreBytes(offs, size, val) {
                let bit_end := shl(3, sub(32, size))
                let mask := shl(bit_end, $MaskForSize(size))
                mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
            }
            function $StorageLoadBytes(offs, size) -> val {
                let word_offs, byte_offs := $ToWordOffs(offs)
                let key := $StorageKey(0, word_offs)
                val := $ExtractBytes(sload(key), byte_offs, size)
                let overflow_bytes := $OverflowBytes(byte_offs, size)
                if $LogicalNot(iszero(overflow_bytes)) {
                    key := $StorageKey(0, add(word_offs, 1))
                    let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
                    val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
                }
            }
            function $StorageStoreBytes(offs, size, bytes) {
                let word_offs, byte_offs := $ToWordOffs(offs)
                let key := $StorageKey(0, word_offs)
                let overflow_bytes := $OverflowBytes(byte_offs, size)
                switch overflow_bytes
                case 0 {
                    sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
                }
                default {
                    // Shift the higher bytes to the right
                    let used_bytes := sub(size, overflow_bytes)
                    let higher_bytes := shr(used_bytes, bytes)
                    let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
                    sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
                    key := $StorageKey(0, add(word_offs, 1))
                    sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
                }
            }
            function $StorageKey(group, word) -> key {
                mstore(32, word)
                mstore(64, shl(224, group))
                key := keccak256(32, 36)
            }
            function $MakeTypeStorageBase(category, type_hash, id) -> offs {
                offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
            }
            function $NewLinkedStorageBase(type_hash) -> offs {
                let key := $StorageKey(1, 1)
                let handle := sload(key)
                sstore(key, add(handle, 1))
                offs := $MakeTypeStorageBase(1, type_hash, handle)
            }
            function $IndexPtr(ptr, offs) -> new_ptr {
                new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
            }
            function $NewTableHandle() -> handle {
                let key := $StorageKey(1, 0)
                handle := sload(key)
                if iszero(handle) {
                    // no tables have been allocated in this contract, need to initialize the counter
                    // to the number of storage groups already statically allocated
                    handle := 2
                }
                sstore(key, add(handle, 1))
            }

            function $MemoryStoreU8(offs, val) {
                // Shortcut via special instruction
                mstore8(offs, val)
            }
            function $MemoryLoadU64(offs) -> val {
                val := $MemoryLoadBytes(offs, 8)
            }
            function $StorageLoadU64(offs) -> val {
                val := $StorageLoadBytes(offs, 8)
            }
            function $MemoryStoreU64(offs, val) {
                $MemoryStoreBytes(offs, 8, val)
            }
            function $LoadU256(ptr) -> val {
                let offs := $OffsetPtr(ptr)
                switch $IsStoragePtr(ptr)
                case 0 {
                    val := $MemoryLoadU256(offs)
                }
                default {
                    val := $StorageLoadU256(offs)
                }
            }
            function $MemoryLoadU256(offs) -> val {
                val := $MemoryLoadBytes(offs, 32)
            }
            function $StorageLoadU256(offs) -> val {
                val := $StorageLoadBytes(offs, 32)
            }
            function $StoreU256(ptr, val) {
                let offs := $OffsetPtr(ptr)
                switch $IsStoragePtr(ptr)
                case 0 {
                    $MemoryStoreU256(offs, val)
                }
                default {
                    $StorageStoreU256(offs, val)
                }
            }
            function $MemoryStoreU256(offs, val) {
                $MemoryStoreBytes(offs, 32, val)
            }
            function $StorageStoreU256(offs, val) {
                $StorageStoreBytes(offs, 32, val)
            }
            function $AlignedStorageLoad(offs) -> val {
                let word_offs := shr(5, offs)
                val := sload($StorageKey(0, word_offs))
            }
            function $CopyMemory(src, dst, size) {
                let num_words, overflow_bytes := $ToWordOffs(size)
                let i := 0
                for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
                    mstore(add(dst, i), mload(add(src, i)))
                }
                if overflow_bytes {
                    let mask := $MaskForSize(sub(32, overflow_bytes))
                    let overflow_offs := mul(num_words, 32)
                    let dst_word := and(mload(add(dst, overflow_offs)), mask)
                    let src_word := and(mload(add(src, overflow_offs)), not(mask))
                    mstore(add(dst, overflow_offs), or(dst_word, src_word))
                }
            }
            function $AddU256(x, y) -> r {
                if lt(sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $Sub(x, y) -> r {
                if lt(x, y) { $AbortBuiltin() }
                r := sub(x, y)
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
            function $GtEq(x, y) -> r {
                r := or(gt(x, y), eq(x, y))
            }
            function $LtEq(x, y) -> r {
                r := or(lt(x, y), eq(x, y))
            }
            function $Neq(x, y) -> r {
                r := $LogicalNot(eq(x, y))
            }
            function $LogicalNot(x) -> r {
                r := iszero(x)
            }
            function $ClosestGreaterPowerOfTwo(x) -> r {
                r := or(r, shr(1, x))
                r := or(r, shr(2, r))
                r := or(r, shr(4, r))
                r := or(r, shr(8, r))
                r := or(r, shr(16, r))
                r := or(r, shr(32, r))
                r := add(x, 1)
            }
            function $RoundUp(value) -> result {
                result := and(add(value, 31), not(31))
            }
            function $AbortNotProtected() {
                if iszero($IsProtected()) {
                    $Abort2(6)
                }
            }
            function $AbortProtected() {
                if $IsProtected() {
                    $Abort2(7)
                }
            }
            function $Abort2(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $IsProtected() -> flag {
                flag := tload(0x0)
            }
            function $Protect() {
                tstore(0x0, 1)
            }
            function $Release() {
                tstore(0x0, 0)
            }
            function $SaveSigner() {
                tstore(0x1, caller())
            }
            function $GetSigner() -> addr {
                if iszero(tload(0x1)) {
                    $Abort2(7)
                }
                addr := tload(0x1)
            }
            function $DeleteSigner() {
                tstore(0x1, 0)
            }
            function $SaveProtectedContract(addr) {
                tstore(0x2, addr)
            }
            function $GetProtectedContract() -> addr {
                addr := tload(0x2)
            }
            function $DeleteProtectedContract() {
                tstore(0x2, 0)
            }
            function $IsReentrancyFlagSet() -> flag {
                flag := tload(0x3)
            }
            function $SizeOFH() -> size {
                size := tload(0x4)
            }
            function $IncrementH() {
                tstore(0x4, add(tload(0x4), 1))
            }
            function $DecrementH() {
                tstore(0x4, sub(tload(0x4), 1))
            }
            function $SizeOfT() -> size {
                size := tload(0x5)
            }
            function $Validate() -> flag {
                $AbortProtected()

                // check size of Hot and Transient
                if $SizeOFH() {
                    $Abort2(1)
                }
                // check if reentrancy flag is set
                if $IsReentrancyFlagSet() {
                    $Abort2(3)
                }
                flag := true
            }
            function $GetTypeHash(resId) -> typeHash {
                let base := $Malloc2(0x40)
                mstore(base, resId)
                mstore(add(base, 0x20), 0x00)
                let key := keccak256(base, 0x40)
                mstore(base, key)
                // log0(base, 0x20)
                typeHash := sload(key)
            }
            function $ComputeHash(addr, resId) -> hash {
                let base := $Malloc2(0x40)
                mstore(base, addr)
                mstore(add(base, 0x20), resId)
                hash := keccak256(base, 0x40)
            }
            function $AbiDecodeProtectionLayer(headStart, dataEnd) -> value0, value1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort2(7) }
                {
                    let offset := 0
                    value0 := $AbiDecodeAddress(add(headStart, offset), dataEnd)
                }
                {
                    let offset := calldataload(add(headStart, 32))
                    if gt(offset, 0xffffffffffffffff) { $Abort2(8) }
                    value1 := $AbiDecodeBytesMemoryPtr(add(headStart, offset), dataEnd)
                }

            }
            function $AbiDecodeAddress(offset, end) -> value {
                value := calldataload(offset)
                if iszero(eq(value, $CleanupAddress(value))) { revert(0, 0) }
            }
            function $AbiDecodeBytesMemoryPtr(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort2(12) }
                let length := calldataload(offset)
                array := $AbiDecodeAvailableLengthBytesMemoryPtr(add(offset, 0x20), length, end)
            }
            function $AbiDecodeAvailableLengthBytesMemoryPtr(src, length, end) -> array {
                array := $Malloc2($ArrayAllocationSizeBytesMemoryPtr(length))
                mstore(array, length)
                let dst := add(array, 0x20)
                if gt(add(src, length), end) { $Abort2(10) }
                $CopyCalldataToMemory(src, dst, length)
            }
            function $Malloc2(size) -> offs {
                offs := mload(0)
                // pad to word size
                mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
            }
            function $ArrayAllocationSizeBytesMemoryPtr(length) -> size {
                // Make sure we can allocate memory without overflow
                if gt(length, 0xffffffffffffffff) { $Abort2(11) }
                size := $RoundUpMulOf32(length)
                // add length slot
                size := add(size, 0x20)
            }
            function $RoundUpMulOf32(value) -> result {
                result := and(add(value, 31), not(31))
            }
            function $CopyCalldataToMemory(src, dst, length) {
                calldatacopy(dst, src, length)
                // clear end
                mstore(add(dst, length), 0)
            }
            function $CleanupAddress(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
            }
        }
    }
}
